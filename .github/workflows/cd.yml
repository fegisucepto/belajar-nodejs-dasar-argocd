name: Continuous Deployment

on:
  push:
    tags:
      - 'v*'
    branches:
      - 'release/*'
      - 'main'

permissions:
  contents: read
  id-token: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.get_tag.outputs.tag_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Get tag
        id: get_tag
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            echo "tag_name=${GITHUB_REF##*/}" >> $GITHUB_OUTPUT
          else
            BRANCH_NAME="${GITHUB_REF#refs/heads/}"
            SAFE_BRANCH=$(echo "$BRANCH_NAME" | tr / -)
            echo "tag_name=latest-${SAFE_BRANCH}" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/belajar-nodejs-dasar:${{ steps.get_tag.outputs.tag_name }}
            ${{ secrets.DOCKERHUB_USERNAME }}/belajar-nodejs-dasar:latest
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install kubectl and minikube
        run: |
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

          # Install minikube
          curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube

      - name: Start Minikube
        run: |
          # Stop and clean Minikube
          minikube delete || true
          
          # Start Minikube with simple configuration
          minikube start \
            --driver=docker \
            --cpus=2 \
            --memory=4g \
            --kubernetes-version=stable \
            --wait=true
          
          # Wait for Minikube to be ready
          minikube status

      - name: Build Docker Image in Minikube
        run: |
          set -e
          
          # Build Docker image in Minikube
          eval $(minikube docker-env)
          docker build -t fegisucepto/belajar-nodejs-dasar:latest .
          docker images | grep belajar-nodejs-dasar
          
      - name: Deploy to Kubernetes
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          TAG: ${{ needs.build-and-push.outputs.image_tag || 'latest' }}
        run: |
          set -e
          
          # Create namespace if not exists
          minikube kubectl -- create namespace belajar-nodejs --dry-run=client -o yaml | minikube kubectl -- apply -f -
          
          # Deploy application
          minikube kubectl -- apply -f k8s/ -n belajar-nodejs
          
          # Wait for MongoDB to be ready
          echo "Waiting for MongoDB to be ready..."
          minikube kubectl -- rollout status deployment/mongo -n belajar-nodejs --timeout=300s
          
          # Check pod status immediately after deployment
          echo "Checking initial pod status..."
          minikube kubectl -- get pods -n belajar-nodejs -o wide
          
          # Wait a bit for pod to start
          echo "Waiting 30 seconds for pod initialization..."
          sleep 30
          
          # Check pod status again
          echo "Checking pod status after initialization..."
          minikube kubectl -- get pods -n belajar-nodejs -o wide
          
          # Check app logs to see what's happening
          echo "Checking application logs..."
          minikube kubectl -- logs -n belajar-nodejs -l app=belajar-nodejs-dasar --tail=50 || echo "No logs available"
          
          # Check MongoDB connection from app perspective
          echo "Testing MongoDB connectivity..."
          minikube kubectl -- exec -n belajar-nodejs deployment/mongo -- mongosh --eval "db.adminCommand('ping')" || echo "MongoDB not responding"
          
          # Check MongoDB service connectivity
          echo "Checking MongoDB service..."
          minikube kubectl -- get svc -n belajar-nodejs
          
          # Try to check app environment
          echo "Checking app environment..."
          minikube kubectl -- exec -n belajar-nodejs deployment/belajar-nodejs-dasar -- env | grep -E '(NODE_ENV|PORT|MONGO_URI)' || echo "Cannot access app container"
          
          # Wait for deployment with extended timeout and better error handling
          echo "Waiting for deployment completion (this may take several minutes)..."
          minikube kubectl -- rollout status deployment/belajar-nodejs-dasar -n belajar-nodejs --timeout=1200s || {
            echo "Deployment timeout - checking final status..."
            minikube kubectl -- get pods -n belajar-nodejs -o wide
            minikube kubectl -- describe deployment belajar-nodejs-dasar -n belajar-nodejs
            echo "Final app logs..."
            minikube kubectl -- logs -n belajar-nodejs -l app=belajar-nodejs-dasar --tail=100 || echo "Cannot get logs"
            exit 1
          }
          
          echo "Deployment completed successfully!"
          
          # Test external access
          echo "Testing external access..."
          minikube service belajar-nodejs-dasar -n belajar-nodejs --url
          minikube kubectl -- exec -n belajar-nodejs deployment/belajar-nodejs-dasar -- curl -s http://localhost:3000/health || echo "Health check failed"
          
          # Get service URL for external access
          SERVICE_URL=$(minikube service belajar-nodejs-dasar -n belajar-nodejs --url)
          echo "Service available at: $SERVICE_URL"
          echo "Health endpoint: $SERVICE_URL/health"

  notify:
    needs: [build-and-push, deploy]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Get deployment status
        id: deployment-status
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "cluster_context=minikube" >> $GITHUB_OUTPUT
            echo "deployment_status=success" >> $GITHUB_OUTPUT
          else
            echo "cluster_context=error" >> $GITHUB_OUTPUT
            echo "deployment_status=failed" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack Notification
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_TITLE: "Deployment ${{ job.status == 'success' && '✅' || '❌' }} - ${{ github.workflow }}"
          SLACK_MESSAGE: |
            *Status*: ${{ job.status == 'success' && 'Berhasil' || 'Gagal' }}
            *Branch/Tag*: ${{ github.ref_name }}
            *Workflow*: ${{ github.workflow }}
            *Commit*: `${{ github.sha }}` 
            *Cluster*: ${{ steps.deployment-status.outputs.cluster_context }}
            *View Logs*: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          SLACK_COLOR: ${{ job.status == 'success' && '#36a64f' || '#ff0000' }}
          MSG_MINIMAL: "true"