name: Continuous Deployment

on:
  push:
    tags:
      - 'v*'
    branches:
      - 'release/*'
      - 'main'

permissions:
  contents: read
  id-token: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.get_tag.outputs.tag_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Get tag
        id: get_tag
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            echo "tag_name=${GITHUB_REF##*/}" >> $GITHUB_OUTPUT
          else
            BRANCH_NAME="${GITHUB_REF#refs/heads/}"
            SAFE_BRANCH=$(echo "$BRANCH_NAME" | tr / -)
            echo "tag_name=latest-${SAFE_BRANCH}" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/belajar-nodejs-dasar:${{ steps.get_tag.outputs.tag_name }}
            ${{ secrets.DOCKERHUB_USERNAME }}/belajar-nodejs-dasar:latest
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install kubectl and minikube
        run: |
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

          # Install minikube
          curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube

      - name: Start Minikube
        run: |
          # Stop Minikube if it's already running
          minikube delete || true
          
          # Start Minikube with required options
          minikube start \
            --driver=docker \
            --force \
            --embed-certs=true \
            --container-runtime=containerd \
            --cni=bridge \
            --cpus=2 \
            --memory=4g \
            --disk-size=20g \
            --kubernetes-version=stable \
            --addons=ingress \
            --alsologtostderr \
            --v=2
          
          # Wait for Minikube to be ready
          minikube status
          minikube kubectl -- get nodes

      - name: Configure kubeconfig
        run: |
          mkdir -p ~/.kube
          minikube update-context
          minikube kubectl -- config view --flatten > ~/.kube/config
          kubectl config set-context --current --namespace=default
          kubectl config use-context minikube
          chmod 600 ~/.kube/config
          echo "KUBECONFIG=~/.kube/config" >> $GITHUB_ENV

      - name: Verify Kubernetes connection
        run: |
          echo "=== MINIKUBE STATUS ==="
          minikube status
          echo "=== K8S VERSION ==="
          kubectl version
          echo "=== NODES ==="
          kubectl get nodes
          echo "=== CLUSTER INFO ==="
          kubectl cluster-info

      - name: Deploy to Kubernetes
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          TAG: ${{ needs.build-and-push.outputs.image_tag || 'latest' }}
        run: |
          set -e
          
          # Create namespace if not exists
          kubectl create namespace belajar-nodejs --dry-run=client -o yaml | kubectl apply -f -
          
          # Deploy application with validation disabled
          kubectl apply -f k8s/ --validate=false
        
          # Wait for deployment to complete
          kubectl rollout status deployment/belajar-nodejs-dasar -n belajar-nodejs --timeout=180s

  notify:
    needs: [build-and-push, deploy]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Get cluster info
        id: cluster-info
        run: |
          echo "cluster_context=minikube" >> $GITHUB_OUTPUT
          echo "Deployment completed successfully"

      - name: Send Slack Notification
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_TITLE: "Deployment ${{ job.status == 'success' && '✅' || '❌' }} - ${{ github.workflow }}"
          SLACK_MESSAGE: |
            *Status*: ${{ job.status == 'success' && 'Berhasil' || 'Gagal' }}
            *Branch/Tag*: ${{ github.ref_name }}
            *Workflow*: ${{ github.workflow }}
            *Commit*: `${{ github.sha }}` 
            *Cluster*: ${{ steps.cluster-info.outputs.cluster_context }}
            *View Logs*: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          SLACK_COLOR: ${{ job.status == 'success' && '#36a64f' || '#ff0000' }}
          MSG_MINIMAL: "true"