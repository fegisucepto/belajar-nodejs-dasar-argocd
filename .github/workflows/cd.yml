name: ArgoCD Continuous Deployment

on:
  push:
    tags:
      - 'v*'
    branches:
      - 'release/*'
      - 'main'
      - 'develop'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'local'
        type: choice
        options:
        - local
        - staging
        - production
      force_sync:
        description: 'Force ArgoCD sync'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  id-token: write

env:
  DOCKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/belajar-nodejs-dasar-argocd
  APP_NAME: belajar-nodejs-dasar
  NAMESPACE: belajar-nodejs

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.get_tag.outputs.tag_name }}
      environment: ${{ steps.env.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Determine environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            ENVIRONMENT="production"
          elif [[ "${GITHUB_REF#refs/heads/}" == "main" ]]; then
            ENVIRONMENT="staging"
          else
            ENVIRONMENT="local"
          fi
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "Deploying to: $ENVIRONMENT"

      - name: Get tag
        id: get_tag
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            echo "tag_name=${GITHUB_REF##*/}" >> $GITHUB_OUTPUT
          else
            BRANCH_NAME="${GITHUB_REF#refs/heads/}"
            SAFE_BRANCH=$(echo "$BRANCH_NAME" | tr / -)
            echo "tag_name=latest-${SAFE_BRANCH}" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.DOCKER_IMAGE }}:${{ steps.get_tag.outputs.tag_name }}
            ${{ env.DOCKER_IMAGE }}:latest
            ${{ env.DOCKER_IMAGE }}:${{ steps.env.outputs.environment }}
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
      
      - name: Setup Minikube for local testing
        run: |
          # Install Minikube
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          chmod +x minikube-linux-amd64
          sudo mv minikube-linux-amd64 /usr/local/bin/minikube
          
          # Start Minikube
          minikube start --driver=docker
          
          # Verify cluster
          kubectl cluster-info
          kubectl get nodes
      
      - name: Deploy to Minikube
        run: |
          echo "Deploying to Minikube cluster..."
          
          # Apply Kubernetes manifests (exclude Argo CD)
          kubectl apply -f k8s/deployment.yaml
          kubectl apply -f k8s/service.yaml
          
          # Wait for deployment
          kubectl wait --for=condition=available --timeout=300s deployment/belajar-nodejs-dasar-argocd || echo "Deployment may take longer"
          
          # Show status
          kubectl get pods -l app=belajar-nodejs-dasar-argocd
          kubectl get services
      
      - name: Debug deployment status
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployments -n belajar-nodejs
          kubectl get pods -n belajar-nodejs -o wide
          kubectl get services -n belajar-nodejs
          
          echo "=== Pod Logs ==="
          kubectl logs -n belajar-nodejs -l app=belajar-nodejs-dasar --tail=20 || echo "No logs available"
          
          echo "=== Events ==="
          kubectl get events -n belajar-nodejs --sort-by='.lastTimestamp' | tail -10
      
      - name: Test application endpoint
        run: |
          echo "Testing application endpoint..."
          
          # Wait untuk pod ready
          echo "Waiting for pods to be ready..."
          kubectl wait --for=condition=ready --timeout=300s pod -l app=belajar-nodejs-dasar -n belajar-nodejs || echo "Pods not ready after timeout"
          
          # Coba dapatkan service URL
          echo "Getting service URL..."
          SERVICE_URL=$(minikube service belajar-nodejs-dasar --url -n belajar-nodejs 2>/dev/null || echo "")
          
          if [ -n "$SERVICE_URL" ]; then
            echo "Service URL: $SERVICE_URL"
            echo "Testing health endpoint..."
            curl -f "$SERVICE_URL/health" || echo "Health check failed, but deployment may have succeeded"
          else
            echo "Service not available, checking NodePort..."
            NODE_PORT=$(kubectl get service belajar-nodejs-dasar -n belajar-nodejs -o jsonpath='{.spec.ports[0].nodePort}')
            if [ -n "$NODE_PORT" ]; then
              echo "NodePort: $NODE_PORT"
              echo "Testing via NodePort..."
              curl -f "http://$(minikube ip):$NODE_PORT/health" || echo "Health check failed, but deployment may have succeeded"
            else
              echo "No service access method available"
            fi
          fi
      
      - name: Update image tag in deployment
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          TAG: ${{ needs.build-and-push.outputs.image_tag || 'latest' }}
        run: |
          echo "Updating image tag to ${TAG} for Argo CD..."
          
          # Setup git config first
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Update image tag di deployment.yaml
          sed -i "s|image: ${DOCKERHUB_USERNAME}/belajar-nodejs-dasar-argocd:latest|image: ${DOCKERHUB_USERNAME}/belajar-nodejs-dasar-argocd:${TAG}|g" k8s/deployment.yaml
          
          # Commit dan push perubahan
          git add k8s/deployment.yaml
          git commit -m "feat: Update image tag to ${TAG} for ${ENVIRONMENT} [skip ci]"
          git push
          
          echo "✅ Image tag updated, Argo CD will sync automatically"
          kubectl get pods -o wide
          kubectl get services

  notify:
    needs: [build-and-push, deploy]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Get deployment status
        id: deployment-status
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "cluster_context=minikube" >> $GITHUB_OUTPUT
            echo "deployment_status=success" >> $GITHUB_OUTPUT
          else
            echo "cluster_context=error" >> $GITHUB_OUTPUT
            echo "deployment_status=failed" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack Notification
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_TITLE: "Deployment ${{ job.status == 'success' && '✅' || '❌' }} - ${{ github.workflow }}"
          SLACK_MESSAGE: |
            *Status*: ${{ job.status == 'success' && 'Berhasil' || 'Gagal' }}
            *Branch/Tag*: ${{ github.ref_name }}
            *Workflow*: ${{ github.workflow }}
            *Commit*: `${{ github.sha }}` 
            *Cluster*: ${{ steps.deployment-status.outputs.cluster_context }}
            *View Logs*: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          SLACK_COLOR: ${{ job.status == 'success' && '#36a64f' || '#ff0000' }}
          MSG_MINIMAL: "true"