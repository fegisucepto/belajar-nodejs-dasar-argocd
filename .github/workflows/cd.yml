name: Continuous Deployment

on:
  push:
    tags:
      - 'v*'
    branches:
      - 'release/*'

permissions:
  contents: read
  id-token: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.get_tag.outputs.tag_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Get tag
        id: get_tag
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            echo "tag_name=${GITHUB_REF##*/}" >> $GITHUB_OUTPUT
          else
            BRANCH_NAME="${GITHUB_REF#refs/heads/}"
            SAFE_BRANCH=$(echo "$BRANCH_NAME" | tr / -)
            echo "tag_name=latest-${SAFE_BRANCH}" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/belajar-nodejs-dasar:${{ steps.get_tag.outputs.tag_name }}
            ${{ secrets.DOCKERHUB_USERNAME }}/belajar-nodejs-dasar:latest
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    env:
      MINIKUBE_HOME: ${{ github.workspace }}/.minikube
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gettext-base curl

      - name: Install kubectl and minikube
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube

      - name: Start Minikube (embed certs)
        run: |
          # start minikube and embed certs into kubeconfig so kubectl can verify server cert
          minikube start --driver=docker --force --embed-certs=true
          minikube addons enable ingress || true
          minikube addons enable metrics-server || true

          # ensure wrapper commands (minikube kubectl -- ...) work
          minikube update-context

          # wait until API server responds (longer wait for CI)
          echo "Waiting for Kubernetes API to be ready..."
          for i in $(seq 1 60); do
            minikube kubectl -- get --raw='/healthz' >/dev/null 2>&1 && break || sleep 3
          done
          echo "minikube should be ready"

      - name: Configure kubeconfig (minikube or external)
        run: |
          set -euo pipefail
          if [ -n "${{ secrets.KUBE_CONFIG }}" ]; then
            echo "Using external kubeconfig from secrets"
            mkdir -p ~/.kube
            echo "${{ secrets.KUBE_CONFIG }}" > ~/.kube/config
            chmod 600 ~/.kube/config
            # show minimized view but don't fail the job if cluster is unreachable
            kubectl config view --minify || true
            kubectl cluster-info || true
            kubectl get nodes || true
          else
            echo "No external kubeconfig provided — using minikube wrapper for kubectl"
            # We'll use `minikube kubectl --` to avoid kubeconfig CA issues
            minikube update-context || true
            minikube kubectl -- get nodes || true
          fi

      - name: Show kubectl context (debug)
        run: |
          # show whatever kubectl currently sees
          kubectl config current-context || true
          kubectl config view --minify || true
          # show minikube-wrapped kubectl nodes too
          echo "minikube kubectl -- get nodes (wrapper):"
          minikube kubectl -- get nodes || true

      - name: Deploy to Kubernetes (use minikube kubectl wrapper)
        id: deploy
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          TAG: ${{ needs.build-and-push.outputs.image_tag || 'latest' }}
        run: |
          set -euo pipefail
          # Create namespace (use wrapper where possible)
          minikube kubectl -- create namespace belajar-nodejs --dry-run=client -o yaml | minikube kubectl -- apply -f -

          # Process deployment manifest with envsubst
          echo "Using image: $DOCKERHUB_USERNAME/belajar-nodejs-dasar:$TAG"
          envsubst < k8s/deployment.yaml > /tmp/deployment-processed.yaml

          echo "=== File deployment yang diproses ==="
          cat /tmp/deployment-processed.yaml
          echo "===================================="

          # Apply manifests via minikube kubectl wrapper to avoid kubeconfig CA issues
          minikube kubectl -- apply -f /tmp/deployment-processed.yaml
          minikube kubectl -- apply -f k8s/service.yaml

          # Wait for rollout (wrapper)
          minikube kubectl -- rollout status deployment/belajar-nodejs-dasar -n belajar-nodejs --timeout=180s

        # If any error, action will fail and next notify job will run (if configured)

  notify:
    needs: [build-and-push, deploy]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
          STATUS: ${{ job.status }}
          MESSAGE: |
            ${{ job.status == 'success' && '✅' || '❌' }} Deployment ${{ github.ref_name }}
            Environment: ${{ contains(github.ref, 'release/') && 'Staging' || 'Production' }}
            Commit: ${{ github.sha }}
            URL: ${{ needs.deploy.outputs.url || 'N/A' }}
            Lihat detail: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
